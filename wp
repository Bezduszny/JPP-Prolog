%Wiktor Petrykowski 371324

ensure_loaded(library(lists)).

% Program - nazwa pliku
analyze(Program, Analyzed) :- 
    see(Program),
    read(variables(Zmienne)),
    read(arrays(Tablice)),
    read(program(Instrukcje)),
    seen,
    Analyzed = [Zmienne, Tablice, Instrukcje].

% Stan = [Zmienne, Tablice, Liczniki], gdzie:
%   Zmienne - slownik zmiennych programu 
%   Tablice - slownik tablic (jako listy prologowe) programu 
%   Liczniki - tablica licznikow (wskazuja aktualny numer instrukcji) procesow

%Tworzy n-elementowa liste o wartosciach E
createArray(0, _, []).
createArray(N, E, [E|L]) :-
  N > 0,
  N1 is N - 1,
  createArray(N1, E, L). 

%Tworzy slownik {ident:liczba} i ustawia wartosci na 0
initVariables([], _{}).
initVariables([Zmienna|Zmienne], Variables) :- 
    initVariables(Zmienne, Vars),
    Variables = Vars.put(Zmienna, 0).

%Tworzy slownik {ident:tablica} i ustawia wartosci na N-elementowe listy o wartosciach 0
initArrays(_, [], _{}).
initArrays(N, [NazwaTablicy|Pozostale], Arrays) :-
    createArray(N, 0, NowaTablica),
    initArrays(N, Pozostale, Arrs),
    Arrays = Arrs.put(NazwaTablicy, NowaTablica).

%initState(+Program, +N, -StanPoczÄ…tkowy)
initState(Zmienne, Tablice, N, StanPoczatkowy) :- 
    createArray(N, 1, Liczniki), % tworzymy liczniki
    initVariables(Zmienne, Variables), %tworzymy slownik zmiennych
    initArrays(N, Tablice, Arrays), % tworzymy slownik tablic
    StanPoczatkowy = [Variables, Arrays, Liczniki].

%run(Instrukcja, Stan, Pid, NowyStan)
run(assign(Zmienna, Wyrazenie), Stan, Pid, NowyStan) :-
    Stan = [Zmienne, Tablice, Liczniki],
    evalWyrArytm(Stan, Wyrazenie, Pid, Wynik),    
    (   (   %Arnosc 0 wiec zwykla zmienna
            functor(Zmienna, Nazwa, 0), 
            NoweZmienne = Zmienne.put(Nazwa, Wynik),
            NoweTablice = Tablice
        )
        ;   %lub
        (   %element tablicy
            functor(Zmienna, array, 2),
            arg(1, Zmienna, NazwaTablicy),
            arg(2, Zmienna, Wyr),
            Tablica = Tablice.get(NazwaTablicy),
            evalWyrArytm(Stan, Wyr, Pid, Indeks),
            replace(Indeks, Tablica, Wynik, NowaTablica),
            NoweZmienne = Zmienne,
            NoweTablice = Tablice.put(NazwaTablicy, NowaTablica)
        )
    ),
    PosredniStan = [NoweZmienne, NoweTablice, Liczniki],
    gotoNext(PosredniStan, Pid, NowyStan).

run(goto(NumerInstrukcji), Stan, Pid, NowyStan) :-
    Stan = [Zmienne, Tablice, Liczniki],
    replace(Pid, Liczniki, NumerInstrukcji, NoweLiczniki),
    NowyStan = [Zmienne, Tablice, NoweLiczniki].

run(condGoto(WyrLogiczne, NumerInstrukcji), Stan, Pid, NowyStan) :-
    Stan = [Zmienne, Tablice, _],
    functor(WyrLogiczne, OperRel, 2),
    arg(1, WyrLogiczne, WyrProste1),  
    arg(2, WyrLogiczne, WyrProste2),
    evalWyrProste(Zmienne, Tablice, WyrProste1, Pid, Wynik1), 
    evalWyrProste(Zmienne, Tablice, WyrProste2, Pid, Wynik2),
    ( porownanie(OperRel, Wynik1, Wynik2) ->
        run(goto(NumerInstrukcji), Stan, Pid, NowyStan)
    ; %else
        gotoNext(Stan, Pid, NowyStan)
    ).

run(sekcja, Stan, Pid, NowyStan) :- gotoNext(Stan, Pid, NowyStan).

gotoNext(Stan, Pid, NowyStan) :-
    Stan = [_, _, Liczniki],
    nth0(Pid, Liczniki, AktualnyNumerInstrukcji),
    NastepnyNumerInstrukcji is AktualnyNumerInstrukcji + 1,
    run(goto(NastepnyNumerInstrukcji), Stan, Pid, NowyStan).

% Podmienia N-ty element listy L na element E, K to nowo powstala lista
replace(N, L, E, K) :-
    nth0(N, L, _, R),
    nth0(N, K, E, R).

%evalWyrArytm(+Stan, +Wyr, -Wynik)
evalWyrArytm([Zmienne, Tablice, _], Wyrazenie, Pid, Wynik) :-
    %Wyrazenie to
    %   wyrazenie proste
    evalWyrProste(Zmienne, Tablice, Wyrazenie, Pid, Wynik);
    %lub
    %   +|-|*|/ wyrazen prostych
    (   functor(Wyrazenie, Oper, 2),
        arg(1, Wyrazenie, WyrProste1),
        arg(2, Wyrazenie, WyrProste2),
        evalWyrProste(Zmienne, Tablice, WyrProste1, Pid, Wynik1),
        evalWyrProste(Zmienne, Tablice, WyrProste2, Pid, Wynik2),
        dzialanie(Oper, Wynik1, Wynik2, Wynik)
    ).

%dzialanie(+Oper, +Liczba1, +Liczb2, -Wynik)
dzialanie(+, Skladnik1, Skladnik2, Wynik) :- Wynik is Skladnik1 + Skladnik2.
dzialanie(*, Czynnik1, Czynnik2, Wynik) :- Wynik is Czynnik1 * Czynnik2.
dzialanie(-, Odjemna, Odjemnik, Wynik) :- Wynik is Odjemna - Odjemnik.
dzialanie(/, Dzielna, Dzielnik, Wynik) :- Wynik is Dzielna / Dzielnik.

%porownanie(OperRel, Liczba1, Liczb2)
porownanie(<, L1, L2) :- L1 < L2.
porownanie(=, L1,  L2) :- L1 =:= L2.
porownanie(<>, L1, L2) :- L1 =\= L2.

%evalWyrProste(+Zmienne, +Wyrazenie, +Pid, -Wynik)
evalWyrProste(Zmienne, Tablice, Wyrazenie, Pid, Wynik) :-
    (number(Wyrazenie), Wynik = Wyrazenie);
    (atom(Wyrazenie), Wyrazenie = pid, Wynik is Pid);
    (atom(Wyrazenie), Wyrazenie \= pid, Wynik = Zmienne.get(Wyrazenie));
    (functor(Wyrazenie, array, 2),
     arg(1, Wyrazenie, Ident), %nazwa tablicy
     arg(2, Wyrazenie, WyrArytm), %indeks tablicy, ktory moze byc wyrazeniem
     evalWyrArytm([Zmienne, Tablice, _], WyrArytm, Pid, Indeks),
     Tablica = Tablice.get(Ident), %wyciagamy odpowiednia tablice ze slownika
     nth0(Indeks, Tablica, Wynik) %sprawdzamy co siedzi pod wyewaluowanym indeksem
    ).

%nextInstruction(+StanWe, PrId, -StanWy)
nextInstruction(program(Instrukcje), StanWe, PrId, StanWy) :-
    nth0(PrId, Instrukcje, Instrukcja),
    functor(Instrukcja, Nazwa, _),
    run(Nazwa, Instrukcja, StanWe, StanWy).

%step(+Program, +StanWe, ?PrId, -StanWy)
% Program to lista instrukcji
step(Program, StanWe, PrId, StanWy) :- 
    StanWe = [Zmienne, Tablice, Liczniki],
    PrId >= 0,
    nth0(PrId, Liczniki, NumerAktualnejInstrukcji),
    nth1(NumerAktualnejInstrukcji, Program, Instrukcja),
    run(Instrukcja, StanWe, PrId, StanWy).

%WERYFIKACJA

verify(N, Program) :- 
    analyze(Program, Analyzed),
    Analyzed = [Zmienne, Tablice, Instrukcje],
    initState(Zmienne, Tablice, 2, StanPoczatkowy),
    \+ walk(N, Instrukcje, StanPoczatkowy, [StanPoczatkowy]),
    write("Program jest poprawny").

range(Low, Low, High).
range(Out,Low,High) :- NewLow is Low+1, NewLow =< High, range(Out, NewLow, High).

czyByl(Stan, PoprzednieStany) :- member(Stan, PoprzednieStany).

% true jesli istnieje niebezpieczny przeplot, false jesli nie istnieje
walk(N, Instrukcje, StanWe, OdwiedzoneStany) :-
    range(Pid, 0, N),
    step(Instrukcje, StanWe, Pid, StanWy),
    (\+ czyByl(StanWy, OdwiedzoneStany)),
    NoweOdwiedzoneStany = [StanWy|OdwiedzoneStany],
    ( czyNiebezpieczny(Instrukcje, StanWy),!
    ;
      walk(N, Instrukcje, StanWy, NoweOdwiedzoneStany)).

czyNiebezpieczny(Instrukcje, Stan) :-
    indeksySekcji(1, Instrukcje, Indeksy),
    Stan = [Zmienne, Tablice, Liczniki],
    ileWSekcji(Indeksy, Liczniki, N),
    N > 1,
    write("Program jest niepoprawny").

ileWSekcji(_, [], 0).
ileWSekcji(IndeksySekcji, Liczniki, N) :-
    Liczniki = [NumerAktualnejInstrukcji|Pozostale],
    ( member(NumerAktualnejInstrukcji, IndeksySekcji) ->
        ileWSekcji(IndeksySekcji, Pozostale, M),
        N is M + 1
    ;
        ileWSekcji(IndeksySekcji, Pozostale, N)
    ).


indeksySekcji(_, [], []).
indeksySekcji(N, Instrukcje, Indeksy) :-
    Instrukcje = [Instrukcja|Pozostale],
    ( Instrukcja = sekcja -> 
        Indeksy = [N | PozostaleIndeksy]
        ;
        Indeksy = PozostaleIndeksy
    ),
    M is N + 1,
    indeksySekcji(M, Pozostale, PozostaleIndeksy).
